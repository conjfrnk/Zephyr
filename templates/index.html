<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Zephyr</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<style>
body,html{margin:0;height:100%; font-family: sans-serif;}
#map{position:absolute;top:0;left:300px;right:0;bottom:0}
#sidebar{position:absolute;top:0;left:0;width:300px;height:100%;
        padding:10px;background:#f4f4f4;box-sizing:border-box;font:14px/1.4 sans-serif; overflow-y: auto;}
.progress{width:80px;height:80px;margin:10px auto} 
.progress svg{width:80px;height:80px}
.progress circle.bg{fill:none;stroke:#e5e7eb;stroke-width:6} 
.progress circle.fg{fill:none;stroke:#3b82f6;stroke-width:6;stroke-linecap:round;
                    transform:rotate(-90deg);transform-origin:center}
.progress text{font-size:18px;text-anchor:middle;dominant-baseline:central; fill: #333;}
#weather{position:absolute;top:10px;right:10px;z-index:800;
        background:rgba(255,255,255,0.9);border:1px solid #ccc;padding:5px 8px;font:12px/1.2 sans-serif; border-radius: 4px;}
.zipLine{font-size:12px; margin: 3px 0; padding: 2px; background-color: #fff; border: 1px solid #ddd; border-radius: 3px;}
.userZipLine{font-size:13px; margin: 4px 0; padding: 3px;}
button{margin-top:8px; margin-bottom: 4px; font:inherit; padding: 6px 10px; background-color: #3b82f6; color:white; border:none; border-radius:4px; cursor:pointer;}
button:hover{background-color: #2563eb;}
button:disabled{background-color: #9ca3af; cursor:not-allowed;}
input[type="text"], input[type="number"]{font:inherit; padding: 4px; border:1px solid #ccc; border-radius:3px; margin-bottom:4px; box-sizing: border-box;}
label{display: block; margin-bottom: 2px;}
hr{border:none; border-top:1px solid #ddd; margin: 15px 0;}
h3,h4{margin-top:15px; margin-bottom:5px; color:#333;}
#msg{font-size:12px;color:#444; min-height: 1.5em; margin-top:5px; background-color: #e0e0e0; padding:5px; border-radius:3px;}
.leaflet-marker-icon { font-weight: bold; } 
.start-finish-pin-start { background-color: lightgreen; } 
.start-finish-pin-finish { background-color: lightcoral; }
#plannedRunInfo { margin-top:10px; margin-bottom: 5px; padding:8px; background-color:#e9e9f2; border: 1px solid #d0d0e0; border-radius:4px; font-size:13px; line-height:1.5;}
#plannedRunInfo strong {color: #333;}
</style>
</head>
<body>
<div id="sidebar">
  <h3>Zephyr Route Planner</h3>
  <label for="zips">Zip codes (e.g., 15243 15228):</label>
  <input id="zips" type="text" style="width:calc(100% - 10px);" placeholder="Enter zip codes">
  <button id="load">Load Roads</button>

  <div id="loadProgressDisplay" style="margin-top:10px;"></div>
  <hr>

  <button id="start">Plan New Route</button><br>
  <label><input id="avoid_hills" type="checkbox"> Avoid hills</label><br>

  <div id="plannedRunInfo"></div> 

  <button id="completeBtn" disabled>Mark Run as Completed</button>
  <div id="msg">Welcome! Load zip codes to begin.</div>
  <hr>

  <h3 style="text-align:center;">Overall Activity Progress</h3>
  <div class="progress">
    <svg viewBox="0 0 36 36">
      <circle class="bg" cx="18" cy="18" r="16"/>
      <circle id="ring" class="fg" cx="18" cy="18" r="16"
              stroke-dasharray="0 100" stroke-dashoffset="100"/> 
      <text id="pct" x="18" y="18">0%</text>
    </svg>
  </div>
  <div id="userZipProgressDisplay" style="text-align:center; margin-top:5px;"></div>
  <hr>

  <h4>Preferences</h4>
  <label for="tmin">Min Ideal Temp (°F): <input id="tmin" type="number" style="width:70px"></label>
  <label for="tmax">Max Ideal Temp (°F): <input id="tmax" type="number" style="width:70px"></label>
  <label for="wmax">Max Wind (mph): <input id="wmax" type="number" style="width:70px"></label>
  <label for="target">Target Distance (mi): <input id="target" type="number" style="width:70px"></label>
  <button id="savePref">Save Preferences</button>
</div>

<div id="map"></div>
<div id="weather" style="display:none"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
const map = L.map('map').setView([40.44, -79.99], 13); 
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19,
  attribution: '© OpenStreetMap contributors'
}).addTo(map);

const graphLayer = L.geoJSON(null, {
  style: f => ({
    color: f.properties.done ? 'green' : '#888', 
    weight: f.properties.done ? 5 : 3, 
    opacity: f.properties.done ? 0.9 : 0.65 
  })
}).addTo(map);

const plannedLayer = L.geoJSON(null, {
  style: { color: 'red', weight: 6, opacity: 0.9 }
}).addTo(map);

const ring = document.getElementById('ring'), pctText = document.getElementById('pct');
const zipsInput = document.getElementById('zips');
const tminInput = document.getElementById('tmin'), tmaxInput = document.getElementById('tmax');
const wmaxInput = document.getElementById('wmax'), targetInput = document.getElementById('target');
const loadBtn = document.getElementById('load');
const startBtn = document.getElementById('start');
const avoidHillsCheck = document.getElementById('avoid_hills');
const completeBtnEl = document.getElementById('completeBtn');
const savePrefBtn = document.getElementById('savePref');
const msgDiv = document.getElementById('msg');
const loadProgressDiv = document.getElementById('loadProgressDisplay');
const userZipProgressDiv = document.getElementById('userZipProgressDisplay');
const weatherDiv = document.getElementById('weather');
const plannedRunInfoDiv = document.getElementById('plannedRunInfo'); 


let currentPrefs = {};
let currentRunId = null;
let currentStartMarker = null;
let startFinishMarkersLayer = L.layerGroup().addTo(map);
let isGraphDataReady = false;

function updateProgressWheel(percentage) {
  const offset = 100 - (percentage || 0); // Ensure percentage is not undefined
  ring.setAttribute('stroke-dashoffset', offset);
  pctText.textContent = (percentage || 0) + '%';
}

function updateZipLoadProgress(zipsStatusData, graphReadyStatus) {
  loadProgressDiv.innerHTML = '';
  if (!zipsStatusData || Object.keys(zipsStatusData).length === 0) { // Added !zipsStatusData check
    if (graphReadyStatus && !zipsInput.value.trim()) {
        loadProgressDiv.innerHTML = '<div class="zipLine">No zip codes loaded. Enter zips and click Load.</div>';
    } else if (!graphReadyStatus && zipsInput.value.trim()) {
        loadProgressDiv.innerHTML = '<div class="zipLine">Preparing to load specified zip codes...</div>';
    } else {
        loadProgressDiv.innerHTML = '<div class="zipLine">Enter zip codes to see loading progress.</div>';
    }
    return;
  }

  for (const [zipcode, status] of Object.entries(zipsStatusData)) {
    const d = document.createElement('div');
    d.className = 'zipLine';
    let roadText = "Roads: Queued";
    let elevText = "Elevation: Queued";

    if (status.road === -1) { 
        roadText = "Roads: Error";
        elevText = "Elevation: -";
    } else if (graphReadyStatus || status.road > 0 || status.elev > 0) { 
        roadText = status.road >= 100 ? "Roads: Loaded" : `Roads: Loading ${status.road}%`;
        if (status.road < 100) {
            elevText = "Elevation: Waiting for roads";
        } else {
            elevText = status.elev >= 100 ? "Elevation: Loaded" : `Elevation: Loading ${status.elev}%`;
        }
    }
    d.textContent = `${zipcode}: ${roadText}, ${elevText}`;
    loadProgressDiv.appendChild(d);
  }
}

function updateUserRunProgressByZip(zipsStatusData) {
  userZipProgressDiv.innerHTML = '';
  if (!zipsStatusData || Object.keys(zipsStatusData).length === 0 && isGraphDataReady) { // Added !zipsStatusData check
     userZipProgressDiv.innerHTML = '<div class="userZipLine">Load zips to see run progress.</div>';
     return;
  }
  if (!zipsStatusData) return; // Should not happen if caught above, but defensive

  for (const [zipcode, status] of Object.entries(zipsStatusData)) {
    const d = document.createElement('div');
    d.className = 'userZipLine';
    d.textContent = `${zipcode}: ${status.done || 0}% explored`; // Use status.done || 0 
    userZipProgressDiv.appendChild(d);
  }
}

function refreshWeather() {
  if (!map) return;
  const center = map.getCenter();
  fetch(`/weather?lat=${center.lat}&lon=${center.lng}`)
    .then(r => r.ok ? r.json() : Promise.reject(`Weather fetch failed: ${r.status}`))
    .then(w => {
      weatherDiv.style.display = 'block';
      weatherDiv.textContent = `${w.temp_f}°F • ${w.short} • ${w.wind_mph} mph winds`;
    })
    .catch(err => { console.error("Error refreshing weather:", err); weatherDiv.style.display = 'none'; });
}
map.on('moveend', refreshWeather);

function initializeApp() {
  Promise.all([
    fetch('/prefs').then(r => r.json()),
    fetch('/status').then(r => r.json())
  ])
  .then(([prefsData, statusData]) => {
    currentPrefs = prefsData;
    zipsInput.value = prefsData.zip_codes || '';
    tminInput.value = prefsData.tmin;
    tmaxInput.value = prefsData.tmax;
    wmaxInput.value = prefsData.wmax; 
    targetInput.value = prefsData.target; 

    isGraphDataReady = statusData.ready;
    updateProgressWheel(statusData.done);
    updateZipLoadProgress(statusData.zips, statusData.ready);
    updateUserRunProgressByZip(statusData.zips);
    
    if (statusData.ready) {
      fetchGraphData().then(refreshWeather); // Chain refreshWeather after graph data
    } else if (prefsData.zip_codes && prefsData.zip_codes.trim() !== '') { // Check if zip_codes is not empty
      msgDiv.textContent = "Graph data loading for saved zip codes...";
      pollStatus(); 
    } else {
      msgDiv.textContent = "Welcome! Enter Zip Codes and click Load Roads.";
    }
  })
  .catch(error => {
    console.error("Initialization error:", error);
    msgDiv.textContent = "Error initializing app. Check console.";
  });
}

function fetchGraphData() {
  msgDiv.textContent = "Fetching map data...";
  return fetch('/graph') 
    .then(r => {
      if (!r.ok) { 
        msgDiv.textContent = `Error fetching map: ${r.status}. Retrying...`;
        setTimeout(pollStatus, 3000); 
        return Promise.reject(`Graph fetch error: ${r.status}`);
      }
      return r.json();
    })
    .then(graphGeoJSON => {
      graphLayer.clearLayers().addData(graphGeoJSON);
      if (graphGeoJSON && graphGeoJSON.features && graphGeoJSON.features.length > 0) {
         map.fitBounds(graphLayer.getBounds(), {padding: [20,20]});
      }
      // msgDiv.textContent = "Map data loaded."; // Keep "Map data loaded. Ready to plan routes." from pollStatus if possible
      // refreshWeather(); // Moved to initializeApp and pollStatus to ensure map bounds are set
      return graphGeoJSON; // Return data for chaining if needed
    })
    .catch(err => {
        console.error("Error in fetchGraphData:", err);
        msgDiv.textContent = "Failed to load map data. Check console.";
        return Promise.reject(err); // Propagate rejection
    });
}

function pollStatus() {
  fetch('/status')
    .then(r => r.ok ? r.json() : Promise.reject(`Status fetch failed: ${r.statusText}`))
    .then(statusData => {
      isGraphDataReady = statusData.ready;
      updateProgressWheel(statusData.done);
      updateZipLoadProgress(statusData.zips, statusData.ready);
      updateUserRunProgressByZip(statusData.zips);

      if (!statusData.ready) {
        if (!msgDiv.textContent.includes("loading")) msgDiv.textContent = "Map data is loading... Updates are live.";
        setTimeout(pollStatus, 2000); 
      } else {
        msgDiv.textContent = "Map data loaded. Ready to plan routes.";
        fetchGraphData().then(refreshWeather); // Fetch graph then refresh weather
      }
    })
    .catch(err => {
        console.error("Error polling status:", err);
        msgDiv.textContent = "Error updating status. Will retry.";
        setTimeout(pollStatus, 5000); 
    });
}

loadBtn.onclick = () => {
  const zipsToLoad = zipsInput.value.trim();
  if (!zipsToLoad) {
    alert('Please enter zip codes.');
    return;
  }
  msgDiv.textContent = `Loading roads for: ${zipsToLoad}...`;
  graphLayer.clearLayers();
  plannedLayer.clearLayers();
  plannedRunInfoDiv.innerHTML = ''; 
  currentRunId = null;
  completeBtnEl.disabled = true;
  isGraphDataReady = false; 

  fetch('/set_zipcodes', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ zips: zipsToLoad })
  })
  .then(r => r.ok ? r.json() : Promise.reject(`Set zips failed: ${r.statusText}`))
  .then(response => {
      if(response.started){
        msgDiv.textContent = `Started loading for ${response.zips_being_loaded.join(', ')}.`;
        pollStatus(); 
      } else {
        msgDiv.textContent = response.error || "Failed to start loading zip codes.";
      }
  })
  .catch(err => {
    console.error("Error setting zip codes:", err);
    msgDiv.textContent = `Error: ${err}`;
  });
};

startBtn.onclick = () => {
  if (!isGraphDataReady) {
    msgDiv.textContent = "Map data is not ready. Please wait or load zip codes.";
    return;
  }
  msgDiv.textContent = 'Fetching previous run locations... Click a pin or on map for custom start.';
  plannedLayer.clearLayers();
  plannedRunInfoDiv.innerHTML = ''; 
  startFinishMarkersLayer.clearLayers();
  if (currentStartMarker) { currentStartMarker.remove(); currentStartMarker = null; }

  fetch('/run_start_finish_points')
    .then(r => r.ok ? r.json() : Promise.reject('Failed to fetch run start/finish points'))
    .then(points => {
      if (points && points.length > 0) {
        points.forEach(p => {
          const iconHtml = `<div style="background-color:${p.type === 'start' ? 'lightgreen' : 'lightcoral'}; padding: 5px; border-radius: 50%; border: 1px solid #333; text-align: center; line-height: 5px; font-size:10px; width:15px; height:15px;">${p.type === 'start' ? 'S' : 'F'}</div>`;
          const customIcon = L.divIcon({ className: `start-finish-pin-${p.type}`, html: iconHtml, iconSize: [15,15], iconAnchor:[7.5, 7.5] });
          const marker = L.marker([p.lat, p.lng], { icon: customIcon, title: `${p.type} of run ${p.run_id} (${p.status})` })
            .addTo(startFinishMarkersLayer);
          marker.on('click', (e) => {
            L.DomEvent.stopPropagation(e);
            startFinishMarkersLayer.clearLayers();
            proceedToPlanRoute(e.latlng.lat, e.latlng.lng);
          });
        });
        msgDiv.textContent = 'Select a start/finish pin or click on the map for a custom start.';
      } else {
        msgDiv.textContent = 'No previous run locations found. Click on the map for a custom start.';
      }
      
      map.once('click', (e) => {
        startFinishMarkersLayer.clearLayers(); // Clear pins if map is clicked instead
        proceedToPlanRoute(e.latlng.lat, e.latlng.lng);
      });
    })
    .catch(err => {
      console.error("Error fetching start/finish points:", err);
      msgDiv.textContent = 'Error fetching locations. Click on map for custom start.';
      map.once('click', (e) => { // Ensure map click is still available on error
        startFinishMarkersLayer.clearLayers();
        proceedToPlanRoute(e.latlng.lat, e.latlng.lng);
      });
    });
};

function proceedToPlanRoute(lat, lon) {
  if (currentStartMarker) { currentStartMarker.remove(); }
  currentStartMarker = L.marker([lat, lon]).addTo(map);
  msgDiv.textContent = 'Planning route...';
  plannedRunInfoDiv.innerHTML = '<i>Planning...</i>'; 
  completeBtnEl.disabled = true;

  const avoidHills = avoidHillsCheck.checked;
  fetch(`/plan_auto?lat=${lat}&lon=${lon}&avoid_hills=${avoidHills}`)
    .then(r => {
      if (!r.ok) return r.text().then(text => Promise.reject(`Route planning server error: ${r.status} ${text}`));
      return r.json();
    })
    .then(gj => {
      if (!gj || Object.keys(gj).length === 0 || !gj.geometry) { // Check for empty object or no geometry
          msgDiv.textContent = 'Could not find a suitable route. Try a different start or options.';
          plannedRunInfoDiv.innerHTML = 'No route found.';
          if(currentStartMarker) {currentStartMarker.remove(); currentStartMarker=null;}
          plannedLayer.clearLayers();
          return null; 
      }
      plannedLayer.clearLayers().addData(gj);
      if (gj.geometry) map.fitBounds(plannedLayer.getBounds(), {padding:[30,30]});
      
      const props = gj.properties || {}; // Ensure properties exist
      const distM = props.distance_m || 0;
      const distMi = (distM / 1609.34).toFixed(2);
      const ascentM = (props.total_ascent_m || 0).toFixed(0);
      const descentM = (props.total_descent_m || 0).toFixed(0);
      
      plannedRunInfoDiv.innerHTML = 
        `<strong>Planned Run:</strong><br>` +
        `Distance: ${distMi} mi (${(distM/1000).toFixed(2)} km)<br>` +
        `Ascent: ${ascentM} m<br>` +
        `Descent: ${descentM} m`;
      
      return fetch('/runs', { 
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
            distance_m: props.distance_m, // Use props.distance_m
            geojson: gj 
        })
      });
    })
    .then(r => {
      if (r === null) return null; 
      if (!r.ok) return r.json().then(err => Promise.reject(`Saving run failed: ${err.error || r.statusText}`));
      return r.json();
    })
    .then(res => {
      if (res && res.run_id) {
        currentRunId = res.run_id;
        completeBtnEl.disabled = false;
        msgDiv.textContent = 'Route planned! Ready to run or mark complete.';
      } else if (res) { 
        msgDiv.textContent = 'Failed to save planned route details.';
        plannedRunInfoDiv.innerHTML = 'Error saving plan.';
        if(currentStartMarker) {currentStartMarker.remove(); currentStartMarker=null;}
      }
    })
    .catch(err => {
        console.error("Error in route planning/saving:", err);
        msgDiv.textContent = `Error: ${err}. Please try again.`;
        plannedRunInfoDiv.innerHTML = 'Route planning error.';
        if(currentStartMarker) {currentStartMarker.remove(); currentStartMarker=null;}
        plannedLayer.clearLayers();
    });
}

completeBtnEl.onclick = () => {
  if (!currentRunId) {
    msgDiv.textContent = "No active run to complete.";
    return;
  }
  msgDiv.textContent = `Completing run ${currentRunId}...`;
  fetch('/runs', {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ run_id: currentRunId })
  })
  .then(r => r.ok ? r.json() : r.text().then(text => Promise.reject(`Completing run server error: ${r.status} ${text}`)))
  .then(res => {
    if (res.ok) {
      msgDiv.textContent = `Run ${currentRunId} marked as completed! Map updating...`;
      // Chain promises correctly: fetchGraphData first, then fetch status
      return fetchGraphData()
        .then(() => fetch('/status')) // If graph fetch ok, then fetch status
        .catch(graphErr => { // Handle error from fetchGraphData
            console.error("Map refresh failed after completing run:", graphErr);
            msgDiv.textContent = "Run completed, but map failed to refresh. Status will update.";
            return fetch('/status'); // Still attempt to fetch status
        });
    } else {
      msgDiv.textContent = `Problem completing run: ${res.warning || 'Server indicated not OK.'}`;
      return Promise.reject("Problem completing run."); // Propagate failure
    }
  })
  .then(statusResponse => { // statusResponse is from fetch('/status')
    if (statusResponse && statusResponse.ok) {
        return statusResponse.json();
    } else if (statusResponse) { // If fetch('/status') itself failed
        return Promise.reject(`Workspaceing status failed: ${statusResponse.statusText}`);
    }
    // If previous promise in chain rejected (e.g. from PUT /runs or inner fetchGraphData catch that re-rejected)
    return null; 
  })
  .then(statusData => {
    if (statusData) {
      updateProgressWheel(statusData.done);
      updateZipLoadProgress(statusData.zips, statusData.ready); 
      updateUserRunProgressByZip(statusData.zips); 
      if (msgDiv.textContent.includes("updating") || msgDiv.textContent.includes("Status will update")) {
        msgDiv.textContent = "Run completed, map and status updated!";
      }
    } else if (!msgDiv.textContent.includes("Error")) {
        // If statusData is null but no specific error message was set from previous steps
        msgDiv.textContent = "Run completed; status update may have failed.";
    }
    // Common cleanup regardless of status update success
    plannedLayer.clearLayers(); 
    plannedRunInfoDiv.innerHTML = ''; 
    if (currentStartMarker) { currentStartMarker.remove(); currentStartMarker = null; }
    completeBtnEl.disabled = true;
    currentRunId = null;
  })
  .catch(err => { // Catch any propagated rejections
    console.error("Error in complete run sequence:", err);
    msgDiv.textContent = `Error completing run: ${err}`;
  });
};

savePrefBtn.onclick = () => {
  const prefsToSave = {
    tmin: parseFloat(tminInput.value),
    tmax: parseFloat(tmaxInput.value),
    wmax: parseFloat(wmaxInput.value),
    target: parseFloat(targetInput.value)
  };
  fetch('/prefs', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(prefsToSave)
  })
  .then(r => r.ok ? r.json() : r.text().then(text => Promise.reject(`Save prefs failed: ${r.status} ${text}`)))
  .then(() => { msgDiv.textContent = 'Preferences saved!'; currentPrefs = prefsToSave; })
  .catch(err => { console.error("Error saving prefs:", err); msgDiv.textContent = `Error: ${err}`;});
};

// --- Initialize ---
initializeApp();

</script>
</body>
</html>
